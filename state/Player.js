import { immerable } from 'immer';
import Route from './Route.js';
import TrainCard from './TrainCard.js';


export default class Player {
  [immerable] = true;

  name = '';
  color = '';
  numTrains = 45;
  score = 0;
  isTurn = false; 
  trainCards = [];
  destTickets = [];
  claimedRoutes = [];
  socketId = '';
  trainCardsLeftToDrawThisTurn = 2;

  constructor(player, trainCards, destTickets) {
    this.name = player.name;
    this.socketId = player.socketId;
    this.trainCards.push(...trainCards);
    this.destTickets.push(...destTickets);
    this.color = player.color;
  }

  /**
   * Method for a player to claim a route. Currently not recieving user input. Completely untested.
   * 
   * @param {Route} route The route the player is claiming
   * @param {String} color The color the player is claiming the route as, cannot be gray
   * @returns The cards played to claim the route as an array, to be added to the discard pile; null if the player is unable to claim the route
   */
  claimRoute(route, color) {
    // this.trainCards.push(new TrainCard('green'))
    // this.trainCards.push(new TrainCard('gray'))

    let colorIndices = [];  //Stores the indices of trainCards that store a card with the proper color
    let wildIndices = [];   //As above, but wilds

    for (let i = 0; i < this.trainCards.length; i++) {
      console.log(this.trainCards[i].color)
      if (this.trainCards[i].color === color) {
        colorIndices.push(i);
        continue;
      }
      if (this.trainCards[i].color === 'gray') {
        wildIndices.push(i);
      }
    }

    let useWilds = false
    if (colorIndices.length < route.length) {
      console.log("You have " + colorIndices.length + " cards of that color, you need " + route.length + ".")
      if (wildIndices.length >= (route.length-colorIndices.length)) {
        console.log("Do you want to use wilds?")
        //(Y/N), get player input
        //yes
        useWilds = true
        //no
        // console.log("Cannot claim that route.")
        // return;
      } else {
        console.log("Cannot claim that route.")
        return;
      }
    }
    
    //prevents playing all cards of a color at once if there are excess
    colorIndices.splice(route.length)
    wildIndices.splice(route.length-colorIndices.length)
    let allIndicesUsed = colorIndices
    //remove cards from hand
    if (useWilds) {
      allIndicesUsed = colorIndices.concat(wildIndices)
    }
    let playedCards = this.removeCardsFromHand(allIndicesUsed, this.trainCards)
    
    //update route
    if ((color === route.color1) || (route.color1 === 'gray')) {
      route.taken1 = true;
    } else if ((color === route.color2) || (route.color2 === 'gray')) {
      route.taken2 = true;
    } else {
      console.log("Cannot claim that route with that color.")
      return
    }

    //update player values
    this.score += route.points
    this.numTrains -= route.length
    this.claimedRoutes.push(route)
    // console.log(this.name + " has " + this.score + " points, " + this.numTrains + " trains, just claimed " + this.claimedRoutes[0].name)

    // for(let i=0; i < playedCards.length; i++){
    //   console.log(playedCards[i].color)
    // }
    return playedCards;
  }

  /**
   * Method generated by ChatGPT using the following prompts:
   * "Given an array  A of select indices of a separate array B, remove the entries from B in the indices given by A",
   * "Add the removed elements from B to an array C as though C was a discard pile for B" 
   * Modified to rename A to indices, B to hand, and C to toDiscard
   * Modified to only return toDiscard, not whatever {hand, toDiscard} is
   * 
   * @param {TrainCard[], DestTicket[]} indices Indices containing the card(s) to be removed
   * @param {TrainCard[], DestTicket[]} hand Hand from which the cards will be removed
   * @returns Cards to be added to the discard pile in the game state
   */
  removeCardsFromHand(indices, hand) {
    // Sort indices in descending order to avoid index shifting
    indices.sort((a, b) => b - a);  //not sure whether this works

    // Initialize array toDiscard to store removed elements
    let toDiscard = [];

    // Remove entries from array hand based on indices provided in array indices
    indices.forEach(index => {
        if (index >= 0 && index < hand.length) {
            // Remove element from array hand and add it to array toDiscard
            toDiscard.push(hand.splice(index, 1)[0]);
        }
    });

    this.isTurn = false
    return toDiscard;
}

    
  //   drawdestTicket(deck: destTicket[]) {
  //     if (!this.isTurn) {
  //       return;
  //     }

  //     if (this.trainCardsLeftToDrawThisTurn === 0) {
  //       return;
  //     }

  //     //empty deck case (rare)
  //     if (deck.length === 0) {
  //       console.log("empty deck");
  //       return;
  //     }
  // // console.log("in",deck)
  //     const el = deck.pop()!;
  //     this.trainCards.push(el);
  //     this.trainCardsLeftToDrawThisTurn -= 1;
  //   }
}
